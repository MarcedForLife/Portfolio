<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Shamballs - Marc Tucker - Portfolio</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Shamballs";
    var mkdocs_page_input_path = "shamballs.md";
    var mkdocs_page_url = "/shamballs/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Marc Tucker - Portfolio</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../killshot/">KillShot</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Shamballs</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#shamballs">Shamballs</a></li>
                
            
                <li class="toctree-l3"><a href="#background">Background</a></li>
                
            
                <li class="toctree-l3"><a href="#project-team-members-contributions">Project Team Members &amp; Contributions</a></li>
                
            
                <li class="toctree-l3"><a href="#screenshots">Screenshots</a></li>
                
            
                <li class="toctree-l3"><a href="#videos">Videos</a></li>
                
            
                <li class="toctree-l3"><a href="#code">Code</a></li>
                
            
                <li class="toctree-l3"><a href="#downloads">Downloads</a></li>
                
            
                <li class="toctree-l3"><a href="#references">References</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../twitcher/">Twitcher</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../precursor/">Precursor</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../resume/">Resume</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../contact/">Contact</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Marc Tucker - Portfolio</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Shamballs</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="shamballs">Shamballs</h1>
<p>Shamballs is 3D competitive singleplayer &amp; multiplayer game where players can race against the clock on custom made levels or battle it our arena style in the multiplayer mode derby!</p>
<h1 id="background">Background</h1>
<p>Shamballs was a three man project created as a group assignment for the Auckland University of Technology. Shamballs was built using the following technologies and languages: </p>
<ul>
<li>
<p>C++</p>
</li>
<li>
<p>DirectX 11</p>
</li>
<li>
<p>DirectX Tool Kit</p>
</li>
<li>
<p>Nvidia PhysX 3.3.3</p>
</li>
<li>
<p>FMOD </p>
</li>
</ul>
<p>This was my second attempt at a game project since KillShot and my second project with C++ and FMOD. However, working with DirectX, the DirectX Tool Kit and PhysX was a new experience but a rather pleasant one. It provided the strength for Shamballs to standout and become the game we set out to make for this assignment.
<br /> <br />
There was only a few small features that did not make it into the project before the deadline that were in the origional project pitch and ultimately the whole team was fullfilled with what made it into the final cut.</p>
<h1 id="project-team-members-contributions">Project Team Members &amp; Contributions</h1>
<ul>
<li><strong>Marc Tucker - marcedforlife@gmail.com</strong><ul>
<li>Created most of the base game and architecture</li>
<li>Created the camera system</li>
<li>Created input control methods</li>
<li>Created the level editor</li>
<li>Created the level system</li>
<li>Co-created the menu system</li>
<li>Extras, testing &amp; bug fixes
<br /> <br /></li>
</ul>
</li>
<li><strong>Sean Chambers - smchambers95@gmail.com</strong><ul>
<li>Implemented sounds</li>
<li>Created game pickups</li>
<li>Created game start and finish entities</li>
<li>Created the resource manager</li>
<li>Created game timers</li>
<li>Extras, testing &amp; bug fixes
<br /> <br /></li>
</ul>
</li>
<li><strong>Mathew Bielby - mathewbielby3@gmail.com</strong><ul>
<li>Created all the multiplayer components</li>
<li>Assisted with base architecture including menu design</li>
<li>Extras, testing &amp; bug fixes</li>
</ul>
</li>
</ul>
<h1 id="screenshots">Screenshots</h1>
<p>In-Game Time Trial:
<img alt="image" src="../img/ShamballsTime1.png" /></p>
<p>In-Game Level Editor:
<img alt="image" src="../img/ShamballsEditor1.png" /></p>
<h1 id="videos">Videos</h1>
<p>Editor &amp; Time Trial Demo:
<a href="https://youtu.be/bNpY-IfdIbA
" target="_blank"><img alt="image" src="../img/ShamballsEditorThumnail.png" />
</a></p>
<p>Derby Multiplayer Demo:
<a href="https://youtu.be/neLKCtIlgGI
" target="_blank"><img alt="image" src="../img/ShamballsDerbyThumnail.png" />
</a></p>
<h1 id="code">Code</h1>
<p>Below I have provided the source code that I wrote for my Level Editor in Shamballs:</p>
<pre><code>#include &quot;pch.h&quot;
#include &quot;Editor.h&quot;

#include &quot;Engine.h&quot;

Editor::Editor(Level* level)
{
    Initialise(level);
}

Editor::~Editor()
{
    if (m_EntitySelection)
    {
        delete m_EntitySelection;
        m_EntitySelection;
    }

    if (m_Level)
    {
        delete m_Level;
        m_Level = 0;
    }
}

void Editor::Initialise(Level* level)
{
    m_Level = level;

    Engine::GetInstance().m_MenuMgr-&gt;AddMenu(MenuType::EDITOR);

    Engine::GetInstance().m_Camera-&gt;SetCameraMode(CameraMode::FREE);

    CycleEntityType(0);
}

void Editor::Update(float deltaTime)
{
    if (!(Engine::GetInstance().m_MenuMgr-&gt;m_Open))
    {
        Engine::GetInstance().m_InputMgr-&gt;ProcessEditorInput(this);

        m_Level-&gt;Update(deltaTime);
        UpdateCurrentSelection(deltaTime);
    }
}

void Editor::Render()
{
    m_Level-&gt;Render();
    if (m_EntitySelection)
    {
        m_EntitySelection-&gt;Render();
    }
    PrintEntitySelection();
}

// Editor level functions
bool Editor::ValidateLevel()
{
    return false;
}

bool Editor::SaveLevel()
{
    return false;
}

void Editor::UpdateCurrentSelection(float deltaTime)
{
    if (m_EntitySelection)
    {
        PxTransform transform = (m_EntitySelection-&gt;GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection-&gt;GetDynamicCollider()-&gt;getGlobalPose() : m_EntitySelection-&gt;GetStaticCollider()-&gt;getGlobalPose();
        PxVec3 location = Engine::GetInstance().m_Camera-&gt;GetWorldLocation();
        PxVec3 camRotation = Engine::GetInstance().m_Camera-&gt;GetWorldRotation();

        float distance = 10.0f;

        transform.p.x = location.x + (distance * cos(camRotation.x) * sin(camRotation.y));
        transform.p.y = location.y + (distance * sin(camRotation.x));
        transform.p.z = location.z + (distance * cos(camRotation.x) * cos(camRotation.y));

        Quaternion q = Quaternion::CreateFromYawPitchRoll(m_EntityRotation.y, m_EntityRotation.x, 0.0f);
        transform.q.w = q.w;
        transform.q.x = q.x;
        transform.q.y = q.y;
        transform.q.z = q.z;

        (m_EntitySelection-&gt;GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection-&gt;GetDynamicCollider()-&gt;setGlobalPose(transform) : m_EntitySelection-&gt;GetStaticCollider()-&gt;setGlobalPose(transform);

        m_EntitySelection-&gt;Update(deltaTime);
    }
}

// Input handling : Selection
// Figure out the new entity type to cycle to
void Editor::CycleEntityType(int input)
{
    // We are now below our range so set it to the top
    if (static_cast&lt;int&gt;(m_EntitySelectionType) + input &lt; 0)
    {
        m_EntitySelectionType = static_cast&lt;EntityType::EntityType&gt;(static_cast&lt;int&gt;(EntityType::COUNT) - 1);
    }
    // We are now above our range so it to the bottom
    else if (static_cast&lt;int&gt;(m_EntitySelectionType) + input &gt;= EntityType::COUNT)
    {
        m_EntitySelectionType = static_cast&lt;EntityType::EntityType&gt;(0);
    }
    // We are still within range so apply the direction
    else
    {
        m_EntitySelectionType = static_cast&lt;EntityType::EntityType&gt;(static_cast&lt;int&gt;(m_EntitySelectionType)+input);
    }

    // Spawn the updated selection
    SpawnEntitySelection();
}

void Editor::CycleEntitySubType(int input)
{
    switch (m_EntitySelectionType)
    {
        case EntityType::WORLDBLOCK:
            // We are bellow our range so cycle to the top
            if (static_cast&lt;int&gt;(m_PhysicsSelectionType)+input &lt; 0)
            {
                m_PhysicsSelectionType = static_cast&lt;PhysicsType::PhysicsType&gt;(static_cast&lt;int&gt;(PhysicsType::COUNT) - 1);
            }
            // We are above our range so cycle to the bottom
            else if (static_cast&lt;int&gt;(m_PhysicsSelectionType)+input &gt;= PhysicsType::COUNT)
            {
                m_PhysicsSelectionType = static_cast&lt;PhysicsType::PhysicsType&gt;(static_cast&lt;int&gt;(0));
            }
            // We are still within range so apply the input
            else
            {
                m_PhysicsSelectionType = static_cast&lt;PhysicsType::PhysicsType&gt;(static_cast&lt;int&gt;(m_PhysicsSelectionType)+input);
            }
            break;
        case EntityType::PICKUP:
            // We are bellow our range so cycle to the top
            if (static_cast&lt;int&gt;(m_PickupSelectionType)+input &lt; 0)
            {
                m_PickupSelectionType = static_cast&lt;PickupType::PickupType&gt;(static_cast&lt;int&gt;(PickupType::COUNT) - 1);
            }
            // We are above our range so cycle to the bottom
            else if (static_cast&lt;int&gt;(m_PickupSelectionType)+input &gt;= PhysicsType::COUNT)
            {
                m_PickupSelectionType = static_cast&lt;PickupType::PickupType&gt;(static_cast&lt;int&gt;(0));
            }
            // We are still within range so apply the input
            else
            {
                m_PickupSelectionType = static_cast&lt;PickupType::PickupType&gt;(static_cast&lt;int&gt;(m_PickupSelectionType)+input);
            }
            break;
    }

    SpawnEntitySelection();
}

void Editor::CycleScale(int input)
{
    float newValue = static_cast&lt;float&gt;(input) / 2.0f;
    float newScale = m_EntityScale.x;

    // If the new scale is lower than our min limit, cycle it to the top (max)
    if (m_EntityScale.x + newValue &lt; m_ScaleMin)
    {
        newScale = m_ScaleMax;
    }
    // If the new scale is higher than our max limit, cycle it to the bottom (min)
    else if (m_EntityScale.x + newValue &gt; m_ScaleMax)
    {
        newScale = m_ScaleMin;
    }
    // We must be still within our scale, so add the new increment (can be negative)
    else
    {
        newScale += newValue;
    }

    // Set the new scale
    m_EntityScale.x = newScale;
    m_EntityScale.y = newScale;
    m_EntityScale.z = newScale;

    // Update the selection
    SpawnEntitySelection();
}

void Editor::CycleTexture(int input)
{
    // We are now below our range so set it to the top
    if (static_cast&lt;int&gt;(m_TextureSelection)+input &lt; 0)
    {
        m_TextureSelection = static_cast&lt;TextureName::TextureName&gt;(static_cast&lt;int&gt;(TextureName::COUNT) - 1);
    }
    // We are now above our range so it to the bottom
    else if (static_cast&lt;int&gt;(m_TextureSelection)+input &gt;= TextureName::COUNT)
    {
        m_TextureSelection = static_cast&lt;TextureName::TextureName&gt;(0);
    }
    // We are still within range so apply the direction
    else
    {
        m_TextureSelection = static_cast&lt;TextureName::TextureName&gt;(static_cast&lt;int&gt;(m_TextureSelection)+input);
    }

    // Spawn the updated selection
    SpawnEntitySelection();
}

void Editor::CycleShape(int input)
{
    // We are now below our range so set it to the top
    if (static_cast&lt;int&gt;(m_ShapeSelectionType)+input &lt; 0)
    {
        m_ShapeSelectionType = static_cast&lt;EntityShape::EntityShape&gt;(static_cast&lt;int&gt;(EntityShape::COUNT) - 1);
    }
    // We are now above our range so it to the bottom
    else if (static_cast&lt;int&gt;(m_ShapeSelectionType)+input &gt;= EntityShape::COUNT)
    {
        m_ShapeSelectionType = static_cast&lt;EntityShape::EntityShape&gt;(0);
    }
    // We are still within range so apply the direction
    else
    {
        m_ShapeSelectionType = static_cast&lt;EntityShape::EntityShape&gt;(static_cast&lt;int&gt;(m_ShapeSelectionType)+input);
    }

    // Spawn the updated selection
    SpawnEntitySelection();
}

void Editor::SpawnEntitySelection()
{
    // Delete the current (if any) entity selection
    if (m_EntitySelection)
    {
        delete m_EntitySelection;
        m_EntitySelection = 0;
    }

    // Init the new selection entity
    switch (m_EntitySelectionType)
    {
    case EntityType::WORLDBLOCK:
        m_EntitySelection = new WorldBlock(EntityType::WORLDBLOCK, m_ShapeSelectionType, m_PhysicsSelectionType, m_TextureSelection, PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);
        break;
    case EntityType::PLAYERSTART:
        m_EntitySelection = new PlayerStart(PxVec3(0.0f, 0.0f, 0.0f));
        break;
    case EntityType::PLAYERFINISH:
        m_EntitySelection = new PlayerFinish(PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);
        break;
    case EntityType::PICKUP:
        m_EntitySelection = new Pickup(m_PickupSelectionType, PxVec3(0.0f, 0.0f, 0.0f));
        break;
    }

    // Check if an entity was spawned and disable it's simulation flag
    if (m_EntitySelection)
    {
        if (m_EntitySelection-&gt;GetPhysicsType() == PhysicsType::DYNAMIC)
        {
            m_EntitySelection-&gt;GetDynamicCollider()-&gt;setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);
        }
        else if (m_EntitySelection-&gt;GetPhysicsType() == PhysicsType::STATIC &amp;&amp; m_EntitySelection-&gt;GetEntityType() != EntityType::PLAYERSTART)
        {
            m_EntitySelection-&gt;GetStaticCollider()-&gt;setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);
        }

        UpdateCurrentSelection(0);
    }
}

void Editor::PickupSelection()
{
    // double check that we aren't holding an entity
    if (!m_EntitySelection)
    {
        PxVec3 location = Engine::GetInstance().m_Camera-&gt;GetWorldLocation();
        PxVec3 camRotation = Engine::GetInstance().m_Camera-&gt;GetWorldRotation();

        PxVec3 origin = Engine::GetInstance().m_Camera-&gt;GetWorldLocation();     // [in] Ray origin
        PxVec3 unitDir = PxVec3(0.0f, 0.0f, 0.0f);                              // [in] Normalized ray direction
        PxReal maxDistance = 30.0f;                                             // [in] Raycast max distance

        float cameraDistance = 0.6f;

        origin.x += (cameraDistance * cos(camRotation.x) * sin(camRotation.y));
        origin.y += (cameraDistance * sin(camRotation.x));
        origin.z += (cameraDistance * cos(camRotation.x) * cos(camRotation.y));

        unitDir.x = cos(camRotation.x) * sin(camRotation.y);
        unitDir.y = sin(camRotation.x);
        unitDir.z = cos(camRotation.x) * cos(camRotation.y);

        // Raycast
        PxRaycastBuffer hit;                                        // [out] Raycast results

        // Raycast against all static &amp; dynamic objects (no filtering)
        // The main result from this call is the closest hit, stored in the 'hit.block' structure
        bool contact = Engine::GetInstance().gScene-&gt;raycast(origin, unitDir, maxDistance, hit);

        // The raycast hit something
        if (contact)
        {
            // Figure out what the raycast hit and remove it from the current level
            Entity* selectedEntity = static_cast&lt;Entity*&gt;(hit.block.actor-&gt;userData);
            switch (selectedEntity-&gt;GetEntityType())
            {
            case EntityType::WORLDBLOCK:
                m_Level-&gt;m_WorldBlocks.erase(std::remove(m_Level-&gt;m_WorldBlocks.begin(), m_Level-&gt;m_WorldBlocks.end(), selectedEntity), m_Level-&gt;m_WorldBlocks.end());
                break;
            case EntityType::PLAYERSTART:
                m_Level-&gt;m_PlayerStart = NULL;
                break;
            case EntityType::PLAYERFINISH:
                m_Level-&gt;m_PlayerFinish = NULL;
                break;
            case EntityType::PICKUP:
            {
                Pickup* pickup = static_cast&lt;Pickup*&gt;(selectedEntity);
                m_Level-&gt;m_Pickups.erase(std::remove(m_Level-&gt;m_Pickups.begin(), m_Level-&gt;m_Pickups.end(), pickup), m_Level-&gt;m_Pickups.end());
                break;
            }
            case EntityType::PLAYER:
                m_Level-&gt;m_LocalPlayer = NULL;
                break;
            }

            // Set our current selection to what ever the raycast hit
            m_EntitySelection = selectedEntity;
        }

    }
}

void Editor::PlaceSelection()
{
    // Add the current selection to the level
    if (m_EntitySelection)
    {
        if (m_EntitySelection-&gt;GetPhysicsType() == PhysicsType::DYNAMIC)
        {
            m_EntitySelection-&gt;GetDynamicCollider()-&gt;setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);
            m_EntitySelection-&gt;GetDynamicCollider()-&gt;wakeUp();
        }
        else
        {
            m_EntitySelection-&gt;GetStaticCollider()-&gt;setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);
        }

        switch (m_EntitySelectionType)
        {
        case EntityType::WORLDBLOCK:
            m_Level-&gt;m_WorldBlocks.push_back(dynamic_cast&lt;WorldBlock*&gt;(m_EntitySelection));
            break;
        case EntityType::PLAYERSTART:
            if(m_Level-&gt;m_PlayerStart)
                delete m_Level-&gt;m_PlayerStart;
            m_Level-&gt;m_PlayerStart = (dynamic_cast&lt;PlayerStart*&gt;(m_EntitySelection));
            break;
        case EntityType::PLAYERFINISH:
            if (m_Level-&gt;m_PlayerFinish)
                delete m_Level-&gt;m_PlayerFinish;
            m_Level-&gt;m_PlayerFinish = (dynamic_cast&lt;PlayerFinish*&gt;(m_EntitySelection));
            break;
        case EntityType::PICKUP:
            m_Level-&gt;m_Pickups.push_back(dynamic_cast&lt;Pickup*&gt;(m_EntitySelection));
            break;
        }

        m_EntitySelection = NULL;
        SpawnEntitySelection();
    }
    // We don't have an entity currently selected so try pickup the looked at entity
    else
    {
        PickupSelection();
    }
}

void Editor::RemoveSelection()
{
    // Delete the current (if any) entity selection
    if (m_EntitySelection)
    {
        delete m_EntitySelection;
        m_EntitySelection = 0;
    }
}

void Editor::PrintEntitySelection()
{
    const wchar_t* description = ((m_EntitySelection) ? m_EntitySelection-&gt;ToString() : NULL); 

    Engine::GetInstance().m_spriteBatch-&gt;Begin();

    Engine::GetInstance().m_font-&gt;DrawString(Engine::GetInstance().m_spriteBatch.get(), (description)? description : L&quot;None&quot;, Engine::GetInstance().m_fontPos, Colors::OrangeRed, 0.0f,
        Vector2((Engine::GetInstance().m_outputWidth / -2.0f) + (std::char_traits&lt;wchar_t&gt;::length((description) ? description : L&quot;None&quot;)* 26.0f) + 20.0f, (Engine::GetInstance().m_outputHeight / 2.0f)));

    Engine::GetInstance().m_spriteBatch-&gt;End();

    delete description;
}

// Input handling : Directional
void Editor::ApplyCameraForwardInput(float input)
{
    Engine::GetInstance().m_Camera-&gt;ApplyForwardInput(input);
}

void Editor::ApplyCameraLeftInput(float input)
{
    Engine::GetInstance().m_Camera-&gt;ApplyLeftInput(input);
}

void Editor::ApplyCameraVerticalInput(float input)
{
    Engine::GetInstance().m_Camera-&gt;ApplyVerticalInput(input);
}

// Input handling : Rotational
void Editor::ApplyCameraYawInput(float input)
{
    Engine::GetInstance().m_Camera-&gt;ApplyYawInput(input);
}

void Editor::ApplyCameraPitchInput(float input)
{
    Engine::GetInstance().m_Camera-&gt;ApplyPitchInput(input);
}

void Editor::ApplySelectionYawInput(float input)
{
    m_EntityRotation.y += input;
}

void Editor::ApplySelectionPitchInput(float input)
{
    m_EntityRotation.x += input;
}
</code></pre>

<h1 id="downloads">Downloads</h1>
<p>Download the latest playable alpha build here: <a href="https://www.dropbox.com/s/mqn8f0rbi9n4wzv/Shamballs%20-%20Alpha.rar?dl=0">Shamballs - Alpha</a>
<br />
Download my personal dev-log for the project here: <a href="../dl/MarcTucker-Shamballs-Dev-Log.pdf">Marc Tucker - Shamballs - Dev Log.pdf</a></p>
<h1 id="references">References</h1>
<p>Audacityteam.org. (2016). Audacity®. [online] 
Available at: http://www.audacityteam.org/ [Accessed 23 Oct. 2016].</p>
<p>GitHub. (2016). Microsoft/DirectXTK. [online] 
Available at: https://github.com/Microsoft/DirectXTK/ [Accessed 23 Oct. 2016].</p>
<p>Docs.nvidia.com. (2016). NVIDIA® PhysX® SDK 3.3.4 Documentation — NVIDIA PhysX SDK 3.3.4 Documentation. [online] 
Available at: http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Index.html [Accessed 23 Oct. 2016].</p>
<p>Jenkinssoftware.com. (2016). RakNet - Multiplayer game network engine. [online] 
Available at: http://www.jenkinssoftware.com/ [Accessed 23 Oct. 2016].</p>
<p>Fmod.org. (2016). FMOD. [online] 
Available at: http://www.fmod.org/ [Accessed 23 Oct. 2016].</p>
<p>OpenGameArt.org. (2016). OpenGameArt.org. [online] 
Available at: http://opengameart.org/ [Accessed 23 Oct. 2016].</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../twitcher/" class="btn btn-neutral float-right" title="Twitcher">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../killshot/" class="btn btn-neutral" title="KillShot"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../killshot/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../twitcher/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
