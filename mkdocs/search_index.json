{
    "docs": [
        {
            "location": "/",
            "text": "What is this place?\n\n\nThis is my personal portfolio! This portfolio contains some of the work I've done and want people to see.\n\n\nplease have a look around!\n\n\nWho is Marc Tucker?\n\n\nI am a student, game and software developer currently working as an intern at Orion Health with a great passion for programming.",
            "title": "Home"
        },
        {
            "location": "/#what-is-this-place",
            "text": "This is my personal portfolio! This portfolio contains some of the work I've done and want people to see.  please have a look around!",
            "title": "What is this place?"
        },
        {
            "location": "/#who-is-marc-tucker",
            "text": "I am a student, game and software developer currently working as an intern at Orion Health with a great passion for programming.",
            "title": "Who is Marc Tucker?"
        },
        {
            "location": "/killshot/",
            "text": "KillShot\n\n\nKillShot is a small game where you recieve contracts to kill a target, the more skilled the takedown the better the grade you recieve at the end.\nThe target will usually be protected and hard to reach. However, this is no problem for you, you are the best of the best. \n\n\nBackground\n\n\nI created KillShot for an independent assignment at the Auckland University of Technology. This project was my first time making a 2D game and my first time using the following technologies and langauges:\n\n\n\n\n\n\nC++\n\n\n\n\n\n\nSDL\n\n\n\n\n\n\nBox2D\n\n\n\n\n\n\nFMOD \n\n\n\n\n\n\nUsing all of the above for the my first time was a huge learning experience and assisted me to ultimately produce something I am very proud of. However, even though I am proud of KillShot due to my scope for the project being quite large for the given timeframe I wasn't able to finish KillShot the way I had hoped.\n\n\nScreenshots\n\n\nMain Menu:\n\n\n\nIn-Game Contract:\n\n\n\nIn-Game Editor:\n\n\n\nVideos\n\n\n\n\n\n\nCode\n\n\nBellow I have provided the source code I wrote for the AI pawn controllers in KillShot:\n\n\n#include \"AIController.h\"\n\n#include \"Box2D.h\"\n#include \"RayCast.h\"\n\nAIController::AIController(Pawn* pawnToPosses, Pawn* playerCharacter)\n{\n    possesPawn(pawnToPosses);\n    this->playerCharacter = playerCharacter;\n}\n\nvoid \nAIController::possesPawn(Pawn* pawnToPosses)\n{\n    possesedPawn = pawnToPosses;\n}\n\nvoid \nAIController::changeState(AIState newState)\n{\n    currentState = newState;\n    stateTimeElapsed = 0.0f;\n}\n\nvoid \nAIController::Process(float deltaTime)\n{\n    if (possesedPawn && playerCharacter)\n    {\n        stateTimeElapsed += deltaTime;\n        coolDownRemaining -= deltaTime;\n\n        // If the player is touching the possed pawn, change the pawns state to alerted\n        for (b2ContactEdge* ce = possesedPawn->GetCollisionBody()->GetContactList(); ce != NULL; ce = ce->next)\n        {\n            Pawn* tmp = static_cast<Pawn*>(ce->other->GetUserData());\n            if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                changeState(ALERTED);\n        }\n\n        // If the pawn is alerted or is facing the players location, send a ray cast to see if the pawn can see the player.\n        if (currentState == ALERTED || (possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() <= possesedPawn->GetPositionX()) || (!possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() >= possesedPawn->GetPositionX()))\n        {\n            b2Vec2 playerLocation = playerCharacter->GetCollisionBody()->GetPosition();\n            b2Vec2 possesionLocation = possesedPawn->GetCollisionBody()->GetPosition();\n\n            RayCast callback;\n\n            possesedPawn->GetCollisionBody()->GetWorld()->RayCast(&callback, possesionLocation, playerLocation);\n\n            if (callback.m_hit)\n            {\n                Pawn* tmp = static_cast<Pawn*>(callback.closestBody->GetUserData());\n\n                // Check whether the raycast found the player before any other obstructions\n                if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                { \n                    if (possesedPawn->IsWeaponEquiped())\n                    {\n                        changeState(ATTACKING);\n\n                        switch (possesedPawn->GetCurrentWeapon()->GetWeaponType())\n                        {\n                        case WeaponType::KNIFE:\n                            possesedPawn->SetHorizontalInput((playerCharacter->GetPositionX() > possesedPawn->GetPositionX()) ? 1.0f : -1.0f);\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            break;\n                        case WeaponType::PISTOL:\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            if (coolDownRemaining <= 0.0f)\n                            {\n                                possesedPawn->PrimaryAttack();\n                                coolDownRemaining = attackCoolDown;\n                            }\n                            break;\n                        }       \n                    }\n                    else\n                    {\n                        changeState(ALERTED);\n                        possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                    }\n\n                }\n                else\n                {\n                    possesedPawn->SetHorizontalInput(0.0f);\n\n                    if (currentState == ATTACKING)\n                        changeState(ALERTED);\n\n                    if (stateTimeElapsed >= 3.0f)\n                    {\n                        changeState(IDLE);\n                        possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            possesedPawn->SetHorizontalInput(0.0f);\n\n            if (stateTimeElapsed >= 3.0f)\n            {\n                changeState(IDLE);\n                possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n            }\n        }\n    }\n}\n\n\n\n\n\nDownloads\n\n\nDownload the latest playable alpha build here: \nKillShot - Alpha\n\n\nReferences\n\n\nCatto, E. (2015). Box2D | A 2D Physics Engine for Games. [online] Box2d.org. \nAvailable at: http://box2d.org/ [Accessed 23 Oct. 2016].\n\n\nFmod.org. (2016). FMOD. [online] \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].\n\n\nYouTube. (2016). NoCopyrightSounds. [online] \nAvailable at: https://www.youtube.com/user/NoCopyrightSounds [Accessed 23 Oct. 2016].\n\n\nOpenGameArt.org. (2016). OpenGameArt.org. [online] \nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].\n\n\nStefan Devai. (2016). Stefan Devai Portfolio. [online] \nAvailable at: http://stefan-devai.github.io/ [Accessed 23 Oct. 2016].\n\n\nLibsdl.org. (2016). Simple DirectMedia Layer - Homepage. [online] \nAvailable at: https://www.libsdl.org/ [Accessed 23 Oct. 2016].",
            "title": "KillShot"
        },
        {
            "location": "/killshot/#killshot",
            "text": "KillShot is a small game where you recieve contracts to kill a target, the more skilled the takedown the better the grade you recieve at the end.\nThe target will usually be protected and hard to reach. However, this is no problem for you, you are the best of the best.",
            "title": "KillShot"
        },
        {
            "location": "/killshot/#background",
            "text": "I created KillShot for an independent assignment at the Auckland University of Technology. This project was my first time making a 2D game and my first time using the following technologies and langauges:    C++    SDL    Box2D    FMOD     Using all of the above for the my first time was a huge learning experience and assisted me to ultimately produce something I am very proud of. However, even though I am proud of KillShot due to my scope for the project being quite large for the given timeframe I wasn't able to finish KillShot the way I had hoped.",
            "title": "Background"
        },
        {
            "location": "/killshot/#screenshots",
            "text": "Main Menu:  In-Game Contract:  In-Game Editor:",
            "title": "Screenshots"
        },
        {
            "location": "/killshot/#videos",
            "text": "",
            "title": "Videos"
        },
        {
            "location": "/killshot/#code",
            "text": "Bellow I have provided the source code I wrote for the AI pawn controllers in KillShot:  #include \"AIController.h\"\n\n#include \"Box2D.h\"\n#include \"RayCast.h\"\n\nAIController::AIController(Pawn* pawnToPosses, Pawn* playerCharacter)\n{\n    possesPawn(pawnToPosses);\n    this->playerCharacter = playerCharacter;\n}\n\nvoid \nAIController::possesPawn(Pawn* pawnToPosses)\n{\n    possesedPawn = pawnToPosses;\n}\n\nvoid \nAIController::changeState(AIState newState)\n{\n    currentState = newState;\n    stateTimeElapsed = 0.0f;\n}\n\nvoid \nAIController::Process(float deltaTime)\n{\n    if (possesedPawn && playerCharacter)\n    {\n        stateTimeElapsed += deltaTime;\n        coolDownRemaining -= deltaTime;\n\n        // If the player is touching the possed pawn, change the pawns state to alerted\n        for (b2ContactEdge* ce = possesedPawn->GetCollisionBody()->GetContactList(); ce != NULL; ce = ce->next)\n        {\n            Pawn* tmp = static_cast<Pawn*>(ce->other->GetUserData());\n            if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                changeState(ALERTED);\n        }\n\n        // If the pawn is alerted or is facing the players location, send a ray cast to see if the pawn can see the player.\n        if (currentState == ALERTED || (possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() <= possesedPawn->GetPositionX()) || (!possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() >= possesedPawn->GetPositionX()))\n        {\n            b2Vec2 playerLocation = playerCharacter->GetCollisionBody()->GetPosition();\n            b2Vec2 possesionLocation = possesedPawn->GetCollisionBody()->GetPosition();\n\n            RayCast callback;\n\n            possesedPawn->GetCollisionBody()->GetWorld()->RayCast(&callback, possesionLocation, playerLocation);\n\n            if (callback.m_hit)\n            {\n                Pawn* tmp = static_cast<Pawn*>(callback.closestBody->GetUserData());\n\n                // Check whether the raycast found the player before any other obstructions\n                if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                { \n                    if (possesedPawn->IsWeaponEquiped())\n                    {\n                        changeState(ATTACKING);\n\n                        switch (possesedPawn->GetCurrentWeapon()->GetWeaponType())\n                        {\n                        case WeaponType::KNIFE:\n                            possesedPawn->SetHorizontalInput((playerCharacter->GetPositionX() > possesedPawn->GetPositionX()) ? 1.0f : -1.0f);\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            break;\n                        case WeaponType::PISTOL:\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            if (coolDownRemaining <= 0.0f)\n                            {\n                                possesedPawn->PrimaryAttack();\n                                coolDownRemaining = attackCoolDown;\n                            }\n                            break;\n                        }       \n                    }\n                    else\n                    {\n                        changeState(ALERTED);\n                        possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                    }\n\n                }\n                else\n                {\n                    possesedPawn->SetHorizontalInput(0.0f);\n\n                    if (currentState == ATTACKING)\n                        changeState(ALERTED);\n\n                    if (stateTimeElapsed >= 3.0f)\n                    {\n                        changeState(IDLE);\n                        possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            possesedPawn->SetHorizontalInput(0.0f);\n\n            if (stateTimeElapsed >= 3.0f)\n            {\n                changeState(IDLE);\n                possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n            }\n        }\n    }\n}",
            "title": "Code"
        },
        {
            "location": "/killshot/#downloads",
            "text": "Download the latest playable alpha build here:  KillShot - Alpha",
            "title": "Downloads"
        },
        {
            "location": "/killshot/#references",
            "text": "Catto, E. (2015). Box2D | A 2D Physics Engine for Games. [online] Box2d.org. \nAvailable at: http://box2d.org/ [Accessed 23 Oct. 2016].  Fmod.org. (2016). FMOD. [online] \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].  YouTube. (2016). NoCopyrightSounds. [online] \nAvailable at: https://www.youtube.com/user/NoCopyrightSounds [Accessed 23 Oct. 2016].  OpenGameArt.org. (2016). OpenGameArt.org. [online] \nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].  Stefan Devai. (2016). Stefan Devai Portfolio. [online] \nAvailable at: http://stefan-devai.github.io/ [Accessed 23 Oct. 2016].  Libsdl.org. (2016). Simple DirectMedia Layer - Homepage. [online] \nAvailable at: https://www.libsdl.org/ [Accessed 23 Oct. 2016].",
            "title": "References"
        },
        {
            "location": "/shamballs/",
            "text": "Shamballs\n\n\nShamballs is 3D competitive singleplayer & multiplayer game where players can race against the clock on custom made levels or battle it our arena style in the multiplayer mode derby!\n\n\nBackground\n\n\nShamballs was a three man project created as a group assignment for the Auckland University of Technology. Shamballs was built using the following technologies and languages: \n\n\n\n\n\n\nC++\n\n\n\n\n\n\nDirectX 11\n\n\n\n\n\n\nDirectX Tool Kit\n\n\n\n\n\n\nNvidia PhysX 3.3.3\n\n\n\n\n\n\nFMOD \n\n\n\n\n\n\nThis was my second attempt at a game project since KillShot and my second project with C++ and FMOD. However, working with DirectX, the DirectX Tool Kit and PhysX was a new experience but a rather pleasant one. It provided the strength for Shamballs to standout and become the game we set out to make for this assignment.\n\n \n\nThere was only a few small features that did not make it into the project before the deadline that were in the origional project pitch and ultimately the whole team was fullfilled with what made it into the final cut.\n\n\nProject Team Members & Contributions\n\n\n\n\nMarc Tucker - marcedforlife@gmail.com\n\n\nCreated most of the base game and architecture\n\n\nCreated the camera system\n\n\nCreated input control methods\n\n\nCreated the level editor\n\n\nCreated the level system\n\n\nCo-created the menu system\n\n\nExtras, testing & bug fixes\n\n \n\n\n\n\n\n\nSean Chambers - smchambers95@gmail.com\n\n\nImplemented sounds\n\n\nCreated game pickups\n\n\nCreated game start and finish entities\n\n\nCreated the resource manager\n\n\nCreated game timers\n\n\nExtras, testing & bug fixes\n\n \n\n\n\n\n\n\nMathew Bielby - mathewbielby3@gmail.com\n\n\nCreated all the multiplayer components\n\n\nAssisted with base architecture including menu design\n\n\nExtras, testing & bug fixes\n\n\n\n\n\n\n\n\nScreenshots\n\n\nIn-Game Time Trial:\n\n\n\nIn-Game Level Editor:\n\n\n\nVideos\n\n\nEditor & Time Trial Demo:\n\n\n\n\n\nDerby Multiplayer Demo:\n\n\n\n\n\nCode\n\n\nBelow I have provided the source code that I wrote for my Level Editor in Shamballs:\n\n\n#include \"pch.h\"\n#include \"Editor.h\"\n\n#include \"Engine.h\"\n\nEditor::Editor(Level* level)\n{\n    Initialise(level);\n}\n\nEditor::~Editor()\n{\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection;\n    }\n\n    if (m_Level)\n    {\n        delete m_Level;\n        m_Level = 0;\n    }\n}\n\nvoid Editor::Initialise(Level* level)\n{\n    m_Level = level;\n\n    Engine::GetInstance().m_MenuMgr->AddMenu(MenuType::EDITOR);\n\n    Engine::GetInstance().m_Camera->SetCameraMode(CameraMode::FREE);\n\n    CycleEntityType(0);\n}\n\nvoid Editor::Update(float deltaTime)\n{\n    if (!(Engine::GetInstance().m_MenuMgr->m_Open))\n    {\n        Engine::GetInstance().m_InputMgr->ProcessEditorInput(this);\n\n        m_Level->Update(deltaTime);\n        UpdateCurrentSelection(deltaTime);\n    }\n}\n\nvoid Editor::Render()\n{\n    m_Level->Render();\n    if (m_EntitySelection)\n    {\n        m_EntitySelection->Render();\n    }\n    PrintEntitySelection();\n}\n\n// Editor level functions\nbool Editor::ValidateLevel()\n{\n    return false;\n}\n\nbool Editor::SaveLevel()\n{\n    return false;\n}\n\nvoid Editor::UpdateCurrentSelection(float deltaTime)\n{\n    if (m_EntitySelection)\n    {\n        PxTransform transform = (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->getGlobalPose() : m_EntitySelection->GetStaticCollider()->getGlobalPose();\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        float distance = 10.0f;\n\n        transform.p.x = location.x + (distance * cos(camRotation.x) * sin(camRotation.y));\n        transform.p.y = location.y + (distance * sin(camRotation.x));\n        transform.p.z = location.z + (distance * cos(camRotation.x) * cos(camRotation.y));\n\n        Quaternion q = Quaternion::CreateFromYawPitchRoll(m_EntityRotation.y, m_EntityRotation.x, 0.0f);\n        transform.q.w = q.w;\n        transform.q.x = q.x;\n        transform.q.y = q.y;\n        transform.q.z = q.z;\n\n        (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->setGlobalPose(transform) : m_EntitySelection->GetStaticCollider()->setGlobalPose(transform);\n\n        m_EntitySelection->Update(deltaTime);\n    }\n}\n\n// Input handling : Selection\n// Figure out the new entity type to cycle to\nvoid Editor::CycleEntityType(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_EntitySelectionType) + input < 0)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(EntityType::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_EntitySelectionType) + input >= EntityType::COUNT)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(m_EntitySelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleEntitySubType(int input)\n{\n    switch (m_EntitySelectionType)\n    {\n        case EntityType::WORLDBLOCK:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PhysicsSelectionType)+input < 0)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(PhysicsType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PhysicsSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(m_PhysicsSelectionType)+input);\n            }\n            break;\n        case EntityType::PICKUP:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PickupSelectionType)+input < 0)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(PickupType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PickupSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(m_PickupSelectionType)+input);\n            }\n            break;\n    }\n\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleScale(int input)\n{\n    float newValue = static_cast<float>(input) / 2.0f;\n    float newScale = m_EntityScale.x;\n\n    // If the new scale is lower than our min limit, cycle it to the top (max)\n    if (m_EntityScale.x + newValue < m_ScaleMin)\n    {\n        newScale = m_ScaleMax;\n    }\n    // If the new scale is higher than our max limit, cycle it to the bottom (min)\n    else if (m_EntityScale.x + newValue > m_ScaleMax)\n    {\n        newScale = m_ScaleMin;\n    }\n    // We must be still within our scale, so add the new increment (can be negative)\n    else\n    {\n        newScale += newValue;\n    }\n\n    // Set the new scale\n    m_EntityScale.x = newScale;\n    m_EntityScale.y = newScale;\n    m_EntityScale.z = newScale;\n\n    // Update the selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleTexture(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_TextureSelection)+input < 0)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(TextureName::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_TextureSelection)+input >= TextureName::COUNT)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(m_TextureSelection)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleShape(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_ShapeSelectionType)+input < 0)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(EntityShape::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_ShapeSelectionType)+input >= EntityShape::COUNT)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(m_ShapeSelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::SpawnEntitySelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n\n    // Init the new selection entity\n    switch (m_EntitySelectionType)\n    {\n    case EntityType::WORLDBLOCK:\n        m_EntitySelection = new WorldBlock(EntityType::WORLDBLOCK, m_ShapeSelectionType, m_PhysicsSelectionType, m_TextureSelection, PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PLAYERSTART:\n        m_EntitySelection = new PlayerStart(PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    case EntityType::PLAYERFINISH:\n        m_EntitySelection = new PlayerFinish(PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PICKUP:\n        m_EntitySelection = new Pickup(m_PickupSelectionType, PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    }\n\n    // Check if an entity was spawned and disable it's simulation flag\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n        else if (m_EntitySelection->GetPhysicsType() == PhysicsType::STATIC && m_EntitySelection->GetEntityType() != EntityType::PLAYERSTART)\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n\n        UpdateCurrentSelection(0);\n    }\n}\n\nvoid Editor::PickupSelection()\n{\n    // double check that we aren't holding an entity\n    if (!m_EntitySelection)\n    {\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        PxVec3 origin = Engine::GetInstance().m_Camera->GetWorldLocation();     // [in] Ray origin\n        PxVec3 unitDir = PxVec3(0.0f, 0.0f, 0.0f);                              // [in] Normalized ray direction\n        PxReal maxDistance = 30.0f;                                             // [in] Raycast max distance\n\n        float cameraDistance = 0.6f;\n\n        origin.x += (cameraDistance * cos(camRotation.x) * sin(camRotation.y));\n        origin.y += (cameraDistance * sin(camRotation.x));\n        origin.z += (cameraDistance * cos(camRotation.x) * cos(camRotation.y));\n\n        unitDir.x = cos(camRotation.x) * sin(camRotation.y);\n        unitDir.y = sin(camRotation.x);\n        unitDir.z = cos(camRotation.x) * cos(camRotation.y);\n\n        // Raycast\n        PxRaycastBuffer hit;                                        // [out] Raycast results\n\n        // Raycast against all static & dynamic objects (no filtering)\n        // The main result from this call is the closest hit, stored in the 'hit.block' structure\n        bool contact = Engine::GetInstance().gScene->raycast(origin, unitDir, maxDistance, hit);\n\n        // The raycast hit something\n        if (contact)\n        {\n            // Figure out what the raycast hit and remove it from the current level\n            Entity* selectedEntity = static_cast<Entity*>(hit.block.actor->userData);\n            switch (selectedEntity->GetEntityType())\n            {\n            case EntityType::WORLDBLOCK:\n                m_Level->m_WorldBlocks.erase(std::remove(m_Level->m_WorldBlocks.begin(), m_Level->m_WorldBlocks.end(), selectedEntity), m_Level->m_WorldBlocks.end());\n                break;\n            case EntityType::PLAYERSTART:\n                m_Level->m_PlayerStart = NULL;\n                break;\n            case EntityType::PLAYERFINISH:\n                m_Level->m_PlayerFinish = NULL;\n                break;\n            case EntityType::PICKUP:\n            {\n                Pickup* pickup = static_cast<Pickup*>(selectedEntity);\n                m_Level->m_Pickups.erase(std::remove(m_Level->m_Pickups.begin(), m_Level->m_Pickups.end(), pickup), m_Level->m_Pickups.end());\n                break;\n            }\n            case EntityType::PLAYER:\n                m_Level->m_LocalPlayer = NULL;\n                break;\n            }\n\n            // Set our current selection to what ever the raycast hit\n            m_EntitySelection = selectedEntity;\n        }\n\n    }\n}\n\nvoid Editor::PlaceSelection()\n{\n    // Add the current selection to the level\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n            m_EntitySelection->GetDynamicCollider()->wakeUp();\n        }\n        else\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n        }\n\n        switch (m_EntitySelectionType)\n        {\n        case EntityType::WORLDBLOCK:\n            m_Level->m_WorldBlocks.push_back(dynamic_cast<WorldBlock*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERSTART:\n            if(m_Level->m_PlayerStart)\n                delete m_Level->m_PlayerStart;\n            m_Level->m_PlayerStart = (dynamic_cast<PlayerStart*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERFINISH:\n            if (m_Level->m_PlayerFinish)\n                delete m_Level->m_PlayerFinish;\n            m_Level->m_PlayerFinish = (dynamic_cast<PlayerFinish*>(m_EntitySelection));\n            break;\n        case EntityType::PICKUP:\n            m_Level->m_Pickups.push_back(dynamic_cast<Pickup*>(m_EntitySelection));\n            break;\n        }\n\n        m_EntitySelection = NULL;\n        SpawnEntitySelection();\n    }\n    // We don't have an entity currently selected so try pickup the looked at entity\n    else\n    {\n        PickupSelection();\n    }\n}\n\nvoid Editor::RemoveSelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n}\n\nvoid Editor::PrintEntitySelection()\n{\n    const wchar_t* description = ((m_EntitySelection) ? m_EntitySelection->ToString() : NULL); \n\n    Engine::GetInstance().m_spriteBatch->Begin();\n\n    Engine::GetInstance().m_font->DrawString(Engine::GetInstance().m_spriteBatch.get(), (description)? description : L\"None\", Engine::GetInstance().m_fontPos, Colors::OrangeRed, 0.0f,\n        Vector2((Engine::GetInstance().m_outputWidth / -2.0f) + (std::char_traits<wchar_t>::length((description) ? description : L\"None\")* 26.0f) + 20.0f, (Engine::GetInstance().m_outputHeight / 2.0f)));\n\n    Engine::GetInstance().m_spriteBatch->End();\n\n    delete description;\n}\n\n// Input handling : Directional\nvoid Editor::ApplyCameraForwardInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyForwardInput(input);\n}\n\nvoid Editor::ApplyCameraLeftInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyLeftInput(input);\n}\n\nvoid Editor::ApplyCameraVerticalInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyVerticalInput(input);\n}\n\n// Input handling : Rotational\nvoid Editor::ApplyCameraYawInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyYawInput(input);\n}\n\nvoid Editor::ApplyCameraPitchInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyPitchInput(input);\n}\n\nvoid Editor::ApplySelectionYawInput(float input)\n{\n    m_EntityRotation.y += input;\n}\n\nvoid Editor::ApplySelectionPitchInput(float input)\n{\n    m_EntityRotation.x += input;\n}\n\n\n\n\nDownloads\n\n\nDownload the latest playable alpha build here: \nShamballs - Alpha\n\n\n\nDownload my personal dev-log for the project here: \nMarc Tucker - Shamballs - Dev Log.pdf\n\n\nReferences\n\n\nAudacityteam.org. (2016). Audacity\u00ae. [online] \nAvailable at: http://www.audacityteam.org/ [Accessed 23 Oct. 2016].\n\n\nGitHub. (2016). Microsoft/DirectXTK. [online] \nAvailable at: https://github.com/Microsoft/DirectXTK/ [Accessed 23 Oct. 2016].\n\n\nDocs.nvidia.com. (2016). NVIDIA\u00ae PhysX\u00ae SDK 3.3.4 Documentation \u2014 NVIDIA PhysX SDK 3.3.4 Documentation. [online] \nAvailable at: http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Index.html [Accessed 23 Oct. 2016].\n\n\nJenkinssoftware.com. (2016). RakNet - Multiplayer game network engine. [online] \nAvailable at: http://www.jenkinssoftware.com/ [Accessed 23 Oct. 2016].\n\n\nFmod.org. (2016). FMOD. [online] \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].\n\n\nOpenGameArt.org. (2016). OpenGameArt.org. [online] \nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].",
            "title": "Shamballs"
        },
        {
            "location": "/shamballs/#shamballs",
            "text": "Shamballs is 3D competitive singleplayer & multiplayer game where players can race against the clock on custom made levels or battle it our arena style in the multiplayer mode derby!",
            "title": "Shamballs"
        },
        {
            "location": "/shamballs/#background",
            "text": "Shamballs was a three man project created as a group assignment for the Auckland University of Technology. Shamballs was built using the following technologies and languages:     C++    DirectX 11    DirectX Tool Kit    Nvidia PhysX 3.3.3    FMOD     This was my second attempt at a game project since KillShot and my second project with C++ and FMOD. However, working with DirectX, the DirectX Tool Kit and PhysX was a new experience but a rather pleasant one. It provided the strength for Shamballs to standout and become the game we set out to make for this assignment.   \nThere was only a few small features that did not make it into the project before the deadline that were in the origional project pitch and ultimately the whole team was fullfilled with what made it into the final cut.",
            "title": "Background"
        },
        {
            "location": "/shamballs/#project-team-members-contributions",
            "text": "Marc Tucker - marcedforlife@gmail.com  Created most of the base game and architecture  Created the camera system  Created input control methods  Created the level editor  Created the level system  Co-created the menu system  Extras, testing & bug fixes      Sean Chambers - smchambers95@gmail.com  Implemented sounds  Created game pickups  Created game start and finish entities  Created the resource manager  Created game timers  Extras, testing & bug fixes      Mathew Bielby - mathewbielby3@gmail.com  Created all the multiplayer components  Assisted with base architecture including menu design  Extras, testing & bug fixes",
            "title": "Project Team Members &amp; Contributions"
        },
        {
            "location": "/shamballs/#screenshots",
            "text": "In-Game Time Trial:  In-Game Level Editor:",
            "title": "Screenshots"
        },
        {
            "location": "/shamballs/#videos",
            "text": "Editor & Time Trial Demo:   Derby Multiplayer Demo:",
            "title": "Videos"
        },
        {
            "location": "/shamballs/#code",
            "text": "Below I have provided the source code that I wrote for my Level Editor in Shamballs:  #include \"pch.h\"\n#include \"Editor.h\"\n\n#include \"Engine.h\"\n\nEditor::Editor(Level* level)\n{\n    Initialise(level);\n}\n\nEditor::~Editor()\n{\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection;\n    }\n\n    if (m_Level)\n    {\n        delete m_Level;\n        m_Level = 0;\n    }\n}\n\nvoid Editor::Initialise(Level* level)\n{\n    m_Level = level;\n\n    Engine::GetInstance().m_MenuMgr->AddMenu(MenuType::EDITOR);\n\n    Engine::GetInstance().m_Camera->SetCameraMode(CameraMode::FREE);\n\n    CycleEntityType(0);\n}\n\nvoid Editor::Update(float deltaTime)\n{\n    if (!(Engine::GetInstance().m_MenuMgr->m_Open))\n    {\n        Engine::GetInstance().m_InputMgr->ProcessEditorInput(this);\n\n        m_Level->Update(deltaTime);\n        UpdateCurrentSelection(deltaTime);\n    }\n}\n\nvoid Editor::Render()\n{\n    m_Level->Render();\n    if (m_EntitySelection)\n    {\n        m_EntitySelection->Render();\n    }\n    PrintEntitySelection();\n}\n\n// Editor level functions\nbool Editor::ValidateLevel()\n{\n    return false;\n}\n\nbool Editor::SaveLevel()\n{\n    return false;\n}\n\nvoid Editor::UpdateCurrentSelection(float deltaTime)\n{\n    if (m_EntitySelection)\n    {\n        PxTransform transform = (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->getGlobalPose() : m_EntitySelection->GetStaticCollider()->getGlobalPose();\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        float distance = 10.0f;\n\n        transform.p.x = location.x + (distance * cos(camRotation.x) * sin(camRotation.y));\n        transform.p.y = location.y + (distance * sin(camRotation.x));\n        transform.p.z = location.z + (distance * cos(camRotation.x) * cos(camRotation.y));\n\n        Quaternion q = Quaternion::CreateFromYawPitchRoll(m_EntityRotation.y, m_EntityRotation.x, 0.0f);\n        transform.q.w = q.w;\n        transform.q.x = q.x;\n        transform.q.y = q.y;\n        transform.q.z = q.z;\n\n        (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->setGlobalPose(transform) : m_EntitySelection->GetStaticCollider()->setGlobalPose(transform);\n\n        m_EntitySelection->Update(deltaTime);\n    }\n}\n\n// Input handling : Selection\n// Figure out the new entity type to cycle to\nvoid Editor::CycleEntityType(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_EntitySelectionType) + input < 0)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(EntityType::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_EntitySelectionType) + input >= EntityType::COUNT)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(m_EntitySelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleEntitySubType(int input)\n{\n    switch (m_EntitySelectionType)\n    {\n        case EntityType::WORLDBLOCK:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PhysicsSelectionType)+input < 0)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(PhysicsType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PhysicsSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(m_PhysicsSelectionType)+input);\n            }\n            break;\n        case EntityType::PICKUP:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PickupSelectionType)+input < 0)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(PickupType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PickupSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(m_PickupSelectionType)+input);\n            }\n            break;\n    }\n\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleScale(int input)\n{\n    float newValue = static_cast<float>(input) / 2.0f;\n    float newScale = m_EntityScale.x;\n\n    // If the new scale is lower than our min limit, cycle it to the top (max)\n    if (m_EntityScale.x + newValue < m_ScaleMin)\n    {\n        newScale = m_ScaleMax;\n    }\n    // If the new scale is higher than our max limit, cycle it to the bottom (min)\n    else if (m_EntityScale.x + newValue > m_ScaleMax)\n    {\n        newScale = m_ScaleMin;\n    }\n    // We must be still within our scale, so add the new increment (can be negative)\n    else\n    {\n        newScale += newValue;\n    }\n\n    // Set the new scale\n    m_EntityScale.x = newScale;\n    m_EntityScale.y = newScale;\n    m_EntityScale.z = newScale;\n\n    // Update the selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleTexture(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_TextureSelection)+input < 0)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(TextureName::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_TextureSelection)+input >= TextureName::COUNT)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(m_TextureSelection)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleShape(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_ShapeSelectionType)+input < 0)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(EntityShape::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_ShapeSelectionType)+input >= EntityShape::COUNT)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(m_ShapeSelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::SpawnEntitySelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n\n    // Init the new selection entity\n    switch (m_EntitySelectionType)\n    {\n    case EntityType::WORLDBLOCK:\n        m_EntitySelection = new WorldBlock(EntityType::WORLDBLOCK, m_ShapeSelectionType, m_PhysicsSelectionType, m_TextureSelection, PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PLAYERSTART:\n        m_EntitySelection = new PlayerStart(PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    case EntityType::PLAYERFINISH:\n        m_EntitySelection = new PlayerFinish(PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PICKUP:\n        m_EntitySelection = new Pickup(m_PickupSelectionType, PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    }\n\n    // Check if an entity was spawned and disable it's simulation flag\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n        else if (m_EntitySelection->GetPhysicsType() == PhysicsType::STATIC && m_EntitySelection->GetEntityType() != EntityType::PLAYERSTART)\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n\n        UpdateCurrentSelection(0);\n    }\n}\n\nvoid Editor::PickupSelection()\n{\n    // double check that we aren't holding an entity\n    if (!m_EntitySelection)\n    {\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        PxVec3 origin = Engine::GetInstance().m_Camera->GetWorldLocation();     // [in] Ray origin\n        PxVec3 unitDir = PxVec3(0.0f, 0.0f, 0.0f);                              // [in] Normalized ray direction\n        PxReal maxDistance = 30.0f;                                             // [in] Raycast max distance\n\n        float cameraDistance = 0.6f;\n\n        origin.x += (cameraDistance * cos(camRotation.x) * sin(camRotation.y));\n        origin.y += (cameraDistance * sin(camRotation.x));\n        origin.z += (cameraDistance * cos(camRotation.x) * cos(camRotation.y));\n\n        unitDir.x = cos(camRotation.x) * sin(camRotation.y);\n        unitDir.y = sin(camRotation.x);\n        unitDir.z = cos(camRotation.x) * cos(camRotation.y);\n\n        // Raycast\n        PxRaycastBuffer hit;                                        // [out] Raycast results\n\n        // Raycast against all static & dynamic objects (no filtering)\n        // The main result from this call is the closest hit, stored in the 'hit.block' structure\n        bool contact = Engine::GetInstance().gScene->raycast(origin, unitDir, maxDistance, hit);\n\n        // The raycast hit something\n        if (contact)\n        {\n            // Figure out what the raycast hit and remove it from the current level\n            Entity* selectedEntity = static_cast<Entity*>(hit.block.actor->userData);\n            switch (selectedEntity->GetEntityType())\n            {\n            case EntityType::WORLDBLOCK:\n                m_Level->m_WorldBlocks.erase(std::remove(m_Level->m_WorldBlocks.begin(), m_Level->m_WorldBlocks.end(), selectedEntity), m_Level->m_WorldBlocks.end());\n                break;\n            case EntityType::PLAYERSTART:\n                m_Level->m_PlayerStart = NULL;\n                break;\n            case EntityType::PLAYERFINISH:\n                m_Level->m_PlayerFinish = NULL;\n                break;\n            case EntityType::PICKUP:\n            {\n                Pickup* pickup = static_cast<Pickup*>(selectedEntity);\n                m_Level->m_Pickups.erase(std::remove(m_Level->m_Pickups.begin(), m_Level->m_Pickups.end(), pickup), m_Level->m_Pickups.end());\n                break;\n            }\n            case EntityType::PLAYER:\n                m_Level->m_LocalPlayer = NULL;\n                break;\n            }\n\n            // Set our current selection to what ever the raycast hit\n            m_EntitySelection = selectedEntity;\n        }\n\n    }\n}\n\nvoid Editor::PlaceSelection()\n{\n    // Add the current selection to the level\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n            m_EntitySelection->GetDynamicCollider()->wakeUp();\n        }\n        else\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n        }\n\n        switch (m_EntitySelectionType)\n        {\n        case EntityType::WORLDBLOCK:\n            m_Level->m_WorldBlocks.push_back(dynamic_cast<WorldBlock*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERSTART:\n            if(m_Level->m_PlayerStart)\n                delete m_Level->m_PlayerStart;\n            m_Level->m_PlayerStart = (dynamic_cast<PlayerStart*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERFINISH:\n            if (m_Level->m_PlayerFinish)\n                delete m_Level->m_PlayerFinish;\n            m_Level->m_PlayerFinish = (dynamic_cast<PlayerFinish*>(m_EntitySelection));\n            break;\n        case EntityType::PICKUP:\n            m_Level->m_Pickups.push_back(dynamic_cast<Pickup*>(m_EntitySelection));\n            break;\n        }\n\n        m_EntitySelection = NULL;\n        SpawnEntitySelection();\n    }\n    // We don't have an entity currently selected so try pickup the looked at entity\n    else\n    {\n        PickupSelection();\n    }\n}\n\nvoid Editor::RemoveSelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n}\n\nvoid Editor::PrintEntitySelection()\n{\n    const wchar_t* description = ((m_EntitySelection) ? m_EntitySelection->ToString() : NULL); \n\n    Engine::GetInstance().m_spriteBatch->Begin();\n\n    Engine::GetInstance().m_font->DrawString(Engine::GetInstance().m_spriteBatch.get(), (description)? description : L\"None\", Engine::GetInstance().m_fontPos, Colors::OrangeRed, 0.0f,\n        Vector2((Engine::GetInstance().m_outputWidth / -2.0f) + (std::char_traits<wchar_t>::length((description) ? description : L\"None\")* 26.0f) + 20.0f, (Engine::GetInstance().m_outputHeight / 2.0f)));\n\n    Engine::GetInstance().m_spriteBatch->End();\n\n    delete description;\n}\n\n// Input handling : Directional\nvoid Editor::ApplyCameraForwardInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyForwardInput(input);\n}\n\nvoid Editor::ApplyCameraLeftInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyLeftInput(input);\n}\n\nvoid Editor::ApplyCameraVerticalInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyVerticalInput(input);\n}\n\n// Input handling : Rotational\nvoid Editor::ApplyCameraYawInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyYawInput(input);\n}\n\nvoid Editor::ApplyCameraPitchInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyPitchInput(input);\n}\n\nvoid Editor::ApplySelectionYawInput(float input)\n{\n    m_EntityRotation.y += input;\n}\n\nvoid Editor::ApplySelectionPitchInput(float input)\n{\n    m_EntityRotation.x += input;\n}",
            "title": "Code"
        },
        {
            "location": "/shamballs/#downloads",
            "text": "Download the latest playable alpha build here:  Shamballs - Alpha  \nDownload my personal dev-log for the project here:  Marc Tucker - Shamballs - Dev Log.pdf",
            "title": "Downloads"
        },
        {
            "location": "/shamballs/#references",
            "text": "Audacityteam.org. (2016). Audacity\u00ae. [online] \nAvailable at: http://www.audacityteam.org/ [Accessed 23 Oct. 2016].  GitHub. (2016). Microsoft/DirectXTK. [online] \nAvailable at: https://github.com/Microsoft/DirectXTK/ [Accessed 23 Oct. 2016].  Docs.nvidia.com. (2016). NVIDIA\u00ae PhysX\u00ae SDK 3.3.4 Documentation \u2014 NVIDIA PhysX SDK 3.3.4 Documentation. [online] \nAvailable at: http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Index.html [Accessed 23 Oct. 2016].  Jenkinssoftware.com. (2016). RakNet - Multiplayer game network engine. [online] \nAvailable at: http://www.jenkinssoftware.com/ [Accessed 23 Oct. 2016].  Fmod.org. (2016). FMOD. [online] \nAvailable at: http://www.fmod.org/ [Accessed 23 Oct. 2016].  OpenGameArt.org. (2016). OpenGameArt.org. [online] \nAvailable at: http://opengameart.org/ [Accessed 23 Oct. 2016].",
            "title": "References"
        },
        {
            "location": "/twitcher/",
            "text": "Twitcher\n\n\nTwitcher is 3D/2D multiplayer shooter where players can go play against each other to become the best!\n\n\nBackground\n\n\nThis project was created as a result of learning SCRUM as a software development methodology. The game is built on the Unreal Engine 4 using blueprint, and intended for use on Windows PC's and Android smart phones.\n\n\nVideos\n\n\nMultiplayer Test:\n\n\n\n\n\nMap & Weapon Changing:\n\n\n\n\n\nDownloads\n\n\nSorry but Twitcher is no longer supported and will no longer contiune to be publicly hosted.\n\n\nReferences\n\n\nEpic Games. (2016). Unreal Engine 4. [online] \nAvailable at: https://www.unrealengine.com/what-is-unreal-engine-4 [Accessed 20 March. 2016].",
            "title": "Twitcher"
        },
        {
            "location": "/twitcher/#twitcher",
            "text": "Twitcher is 3D/2D multiplayer shooter where players can go play against each other to become the best!",
            "title": "Twitcher"
        },
        {
            "location": "/twitcher/#background",
            "text": "This project was created as a result of learning SCRUM as a software development methodology. The game is built on the Unreal Engine 4 using blueprint, and intended for use on Windows PC's and Android smart phones.",
            "title": "Background"
        },
        {
            "location": "/twitcher/#videos",
            "text": "Multiplayer Test:   Map & Weapon Changing:",
            "title": "Videos"
        },
        {
            "location": "/twitcher/#downloads",
            "text": "Sorry but Twitcher is no longer supported and will no longer contiune to be publicly hosted.",
            "title": "Downloads"
        },
        {
            "location": "/twitcher/#references",
            "text": "Epic Games. (2016). Unreal Engine 4. [online] \nAvailable at: https://www.unrealengine.com/what-is-unreal-engine-4 [Accessed 20 March. 2016].",
            "title": "References"
        },
        {
            "location": "/precursor/",
            "text": "Precursor\n\n\nThe story for Precursor is still under wraps.\n\n\nBackground\n\n\nThis project is a restart of my first Unreal Engine 4 project \"Forge\". And will prove to be my most ambiguous project yet.\n\n\nVideos\n\n\nSmall Demo:\n\n\n\n\n\nDownloads\n\n\nSorry, this project is still too early in development to provide a playable alpha.\n\n\nReferences\n\n\nEpic Games. (2016). Unreal Engine 4. [online] \nAvailable at: https://www.unrealengine.com/what-is-unreal-engine-4 [Accessed 17 April. 2016].\n\n\nIronBelly Studios. (2016). IronBelly Studios. [online] \nAvailable at: http://ironbellystudios.com/ [Accessed 17 April. 2016].\n\n\nCubit Studios. (2016). Cubit Studios. [online] \nAvailable at: http://www.cubitstudios.com/ [Accessed 17 April. 2016].",
            "title": "Precursor"
        },
        {
            "location": "/precursor/#precursor",
            "text": "The story for Precursor is still under wraps.",
            "title": "Precursor"
        },
        {
            "location": "/precursor/#background",
            "text": "This project is a restart of my first Unreal Engine 4 project \"Forge\". And will prove to be my most ambiguous project yet.",
            "title": "Background"
        },
        {
            "location": "/precursor/#videos",
            "text": "Small Demo:",
            "title": "Videos"
        },
        {
            "location": "/precursor/#downloads",
            "text": "Sorry, this project is still too early in development to provide a playable alpha.",
            "title": "Downloads"
        },
        {
            "location": "/precursor/#references",
            "text": "Epic Games. (2016). Unreal Engine 4. [online] \nAvailable at: https://www.unrealengine.com/what-is-unreal-engine-4 [Accessed 17 April. 2016].  IronBelly Studios. (2016). IronBelly Studios. [online] \nAvailable at: http://ironbellystudios.com/ [Accessed 17 April. 2016].  Cubit Studios. (2016). Cubit Studios. [online] \nAvailable at: http://www.cubitstudios.com/ [Accessed 17 April. 2016].",
            "title": "References"
        },
        {
            "location": "/resume/",
            "text": "Download: \nMarc Tucker - Resume.pdf",
            "title": "Resume"
        },
        {
            "location": "/contact/",
            "text": "Feel free to contact me at the following email:\n\n\nmarcedforlife@gmail.com\n\n\nMarc Tucker",
            "title": "Contact"
        }
    ]
}