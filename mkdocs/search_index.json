{
    "docs": [
        {
            "location": "/",
            "text": "What is this place?\n\n\nThis is my personal portfolio! This portfolio contains some of the work I've done and want people to see.\n\n\nplease have a look around!\n\n\nWho is Marc Tucker?\n\n\nI am a student, game and software developer currently working as an intern at Orion Health with a great passion for programming.",
            "title": "Home"
        },
        {
            "location": "/#what-is-this-place",
            "text": "This is my personal portfolio! This portfolio contains some of the work I've done and want people to see.  please have a look around!",
            "title": "What is this place?"
        },
        {
            "location": "/#who-is-marc-tucker",
            "text": "I am a student, game and software developer currently working as an intern at Orion Health with a great passion for programming.",
            "title": "Who is Marc Tucker?"
        },
        {
            "location": "/killshot/",
            "text": "KillShot\n\n\nKillShot is a small game where you recieve contracts to kill a target, the more skilled the takedown the better the grade you recieve at the end.\nThe target will usually be protected and hard to reach. However, this is no problem for you, you are the best of the best. \n\n\nBackground\n\n\nI created KillShot for an independent assignment at the Auckland University of Technology. This project was my first time making a 2D game and my first time using the following technologies and langauges:\n\n\n\n\n\n\nC++\n\n\n\n\n\n\nSDL\n\n\n\n\n\n\nBox2D\n\n\n\n\n\n\nFMOD \n\n\n\n\n\n\nUsing all of the above for the my first time was a huge learning experience and assisted me to ultimately produce something I am very proud of. However, even though I am proud of KillShot due to my scope for the project being quite large for the given timeframe I wasn't able to finish KillShot the way I had hoped.\n\n\nScreenshots\n\n\nMain Menu:\n\n\n\nIn-Game Contract:\n\n\n\nIn-Game Editor:\n\n\n\nVideos\n\n\nComming soon\n\n\nCode\n\n\nBellow I have provided the source code I wrote for the AI pawn controllers in KillShot:\n\n\n#include \"AIController.h\"\n\n#include \"Box2D.h\"\n#include \"RayCast.h\"\n\nAIController::AIController(Pawn* pawnToPosses, Pawn* playerCharacter)\n{\n    possesPawn(pawnToPosses);\n    this->playerCharacter = playerCharacter;\n}\n\nvoid \nAIController::possesPawn(Pawn* pawnToPosses)\n{\n    possesedPawn = pawnToPosses;\n}\n\nvoid \nAIController::changeState(AIState newState)\n{\n    currentState = newState;\n    stateTimeElapsed = 0.0f;\n}\n\nvoid \nAIController::Process(float deltaTime)\n{\n    if (possesedPawn && playerCharacter)\n    {\n        stateTimeElapsed += deltaTime;\n        coolDownRemaining -= deltaTime;\n\n        // If the player is touching the possed pawn, change the pawns state to alerted\n        for (b2ContactEdge* ce = possesedPawn->GetCollisionBody()->GetContactList(); ce != NULL; ce = ce->next)\n        {\n            Pawn* tmp = static_cast<Pawn*>(ce->other->GetUserData());\n            if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                changeState(ALERTED);\n        }\n\n        // If the pawn is alerted or is facing the players location, send a ray cast to see if the pawn can see the player.\n        if (currentState == ALERTED || (possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() <= possesedPawn->GetPositionX()) || (!possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() >= possesedPawn->GetPositionX()))\n        {\n            b2Vec2 playerLocation = playerCharacter->GetCollisionBody()->GetPosition();\n            b2Vec2 possesionLocation = possesedPawn->GetCollisionBody()->GetPosition();\n\n            RayCast callback;\n\n            possesedPawn->GetCollisionBody()->GetWorld()->RayCast(&callback, possesionLocation, playerLocation);\n\n            if (callback.m_hit)\n            {\n                Pawn* tmp = static_cast<Pawn*>(callback.closestBody->GetUserData());\n\n                // Check whether the raycast found the player before any other obstructions\n                if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                { \n                    if (possesedPawn->IsWeaponEquiped())\n                    {\n                        changeState(ATTACKING);\n\n                        switch (possesedPawn->GetCurrentWeapon()->GetWeaponType())\n                        {\n                        case WeaponType::KNIFE:\n                            possesedPawn->SetHorizontalInput((playerCharacter->GetPositionX() > possesedPawn->GetPositionX()) ? 1.0f : -1.0f);\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            break;\n                        case WeaponType::PISTOL:\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            if (coolDownRemaining <= 0.0f)\n                            {\n                                possesedPawn->PrimaryAttack();\n                                coolDownRemaining = attackCoolDown;\n                            }\n                            break;\n                        }       \n                    }\n                    else\n                    {\n                        changeState(ALERTED);\n                        possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                    }\n\n                }\n                else\n                {\n                    possesedPawn->SetHorizontalInput(0.0f);\n\n                    if (currentState == ATTACKING)\n                        changeState(ALERTED);\n\n                    if (stateTimeElapsed >= 3.0f)\n                    {\n                        changeState(IDLE);\n                        possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            possesedPawn->SetHorizontalInput(0.0f);\n\n            if (stateTimeElapsed >= 3.0f)\n            {\n                changeState(IDLE);\n                possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n            }\n        }\n    }\n}\n\n\n\n\n\nDownloads\n\n\nDownload the latest playable alpha build here: \nKillShot - Alpha",
            "title": "KillShot"
        },
        {
            "location": "/killshot/#killshot",
            "text": "KillShot is a small game where you recieve contracts to kill a target, the more skilled the takedown the better the grade you recieve at the end.\nThe target will usually be protected and hard to reach. However, this is no problem for you, you are the best of the best.",
            "title": "KillShot"
        },
        {
            "location": "/killshot/#background",
            "text": "I created KillShot for an independent assignment at the Auckland University of Technology. This project was my first time making a 2D game and my first time using the following technologies and langauges:    C++    SDL    Box2D    FMOD     Using all of the above for the my first time was a huge learning experience and assisted me to ultimately produce something I am very proud of. However, even though I am proud of KillShot due to my scope for the project being quite large for the given timeframe I wasn't able to finish KillShot the way I had hoped.",
            "title": "Background"
        },
        {
            "location": "/killshot/#screenshots",
            "text": "Main Menu:  In-Game Contract:  In-Game Editor:",
            "title": "Screenshots"
        },
        {
            "location": "/killshot/#videos",
            "text": "Comming soon",
            "title": "Videos"
        },
        {
            "location": "/killshot/#code",
            "text": "Bellow I have provided the source code I wrote for the AI pawn controllers in KillShot:  #include \"AIController.h\"\n\n#include \"Box2D.h\"\n#include \"RayCast.h\"\n\nAIController::AIController(Pawn* pawnToPosses, Pawn* playerCharacter)\n{\n    possesPawn(pawnToPosses);\n    this->playerCharacter = playerCharacter;\n}\n\nvoid \nAIController::possesPawn(Pawn* pawnToPosses)\n{\n    possesedPawn = pawnToPosses;\n}\n\nvoid \nAIController::changeState(AIState newState)\n{\n    currentState = newState;\n    stateTimeElapsed = 0.0f;\n}\n\nvoid \nAIController::Process(float deltaTime)\n{\n    if (possesedPawn && playerCharacter)\n    {\n        stateTimeElapsed += deltaTime;\n        coolDownRemaining -= deltaTime;\n\n        // If the player is touching the possed pawn, change the pawns state to alerted\n        for (b2ContactEdge* ce = possesedPawn->GetCollisionBody()->GetContactList(); ce != NULL; ce = ce->next)\n        {\n            Pawn* tmp = static_cast<Pawn*>(ce->other->GetUserData());\n            if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                changeState(ALERTED);\n        }\n\n        // If the pawn is alerted or is facing the players location, send a ray cast to see if the pawn can see the player.\n        if (currentState == ALERTED || (possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() <= possesedPawn->GetPositionX()) || (!possesedPawn->IsHFlipped() && playerCharacter->GetPositionX() >= possesedPawn->GetPositionX()))\n        {\n            b2Vec2 playerLocation = playerCharacter->GetCollisionBody()->GetPosition();\n            b2Vec2 possesionLocation = possesedPawn->GetCollisionBody()->GetPosition();\n\n            RayCast callback;\n\n            possesedPawn->GetCollisionBody()->GetWorld()->RayCast(&callback, possesionLocation, playerLocation);\n\n            if (callback.m_hit)\n            {\n                Pawn* tmp = static_cast<Pawn*>(callback.closestBody->GetUserData());\n\n                // Check whether the raycast found the player before any other obstructions\n                if (tmp && tmp->GetPawnType() == PawnType::PLAYER)\n                { \n                    if (possesedPawn->IsWeaponEquiped())\n                    {\n                        changeState(ATTACKING);\n\n                        switch (possesedPawn->GetCurrentWeapon()->GetWeaponType())\n                        {\n                        case WeaponType::KNIFE:\n                            possesedPawn->SetHorizontalInput((playerCharacter->GetPositionX() > possesedPawn->GetPositionX()) ? 1.0f : -1.0f);\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            break;\n                        case WeaponType::PISTOL:\n                            possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                            if (coolDownRemaining <= 0.0f)\n                            {\n                                possesedPawn->PrimaryAttack();\n                                coolDownRemaining = attackCoolDown;\n                            }\n                            break;\n                        }       \n                    }\n                    else\n                    {\n                        changeState(ALERTED);\n                        possesedPawn->SetPawnLookVector(playerCharacter->GetPositionX(), playerCharacter->GetPositionY(), false);\n                    }\n\n                }\n                else\n                {\n                    possesedPawn->SetHorizontalInput(0.0f);\n\n                    if (currentState == ATTACKING)\n                        changeState(ALERTED);\n\n                    if (stateTimeElapsed >= 3.0f)\n                    {\n                        changeState(IDLE);\n                        possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            possesedPawn->SetHorizontalInput(0.0f);\n\n            if (stateTimeElapsed >= 3.0f)\n            {\n                changeState(IDLE);\n                possesedPawn->SetPawnLookVector(1.0f, 0.01f, true);\n            }\n        }\n    }\n}",
            "title": "Code"
        },
        {
            "location": "/killshot/#downloads",
            "text": "Download the latest playable alpha build here:  KillShot - Alpha",
            "title": "Downloads"
        },
        {
            "location": "/shamballs/",
            "text": "Shamballs\n\n\nShamballs is 3D competitive singleplayer & multiplayer game where players can race against the clock on custom made levels or battle it our arena style in the multiplayer mode derby!\n\n\nBackground\n\n\nShamballs was a three man project created as a group assignment for the Auckland University of Technology. Shamballs was built using the following technologies and languages: \n\n\n\n\n\n\nC++\n\n\n\n\n\n\nDirectX 11\n\n\n\n\n\n\nDirectX Tool Kit\n\n\n\n\n\n\nNvidia PhysX 3.3.3\n\n\n\n\n\n\nFMOD \n\n\n\n\n\n\nThis was my second attempt at a game project since KillShot and my second project with C++ and FMOD. However, working with DirectX, the DirectX Tool Kit and PhysX was a new experience but a rather pleasant one. It provided the strength for Shamballs to standout and become the game we set out to make for this assignment.\n\n \n\nThere was only a few small features that did not make it into the project before the deadline that were in the origional project pitch and ultimately the whole team was fullfilled with what made it into the final cut.\n\n\nProject Team Members & Contributions\n\n\n\n\nMarc Tucker - marcedforlife@gmail.com\n\n\nCreated most of the base game and architecture\n\n\nCreated the camera system\n\n\nCreated input control methods\n\n\nCreated the level editor\n\n\nCreated the level system\n\n\nCo-created the menu system\n\n\nSmall extras & bug fixes\n\n \n\n\n\n\n\n\nSean Chambers - smchambers95@gmail.com\n\n\nImplemented sounds\n\n\nCreated game pickups\n\n\nCreated game timers\n\n\nSmall extras\n\n \n\n\n\n\n\n\nMathew Bielby - mathewbielby3@gmail.com\n\n\nCreated all the multiplayer components\n\n\nAssisted with base architecture including menu design\n\n\nSmall extras\n\n\n\n\n\n\n\n\nScreenshots\n\n\nIn-Game Time Trial:\n\n\n\nIn-Game Level Editor:\n\n\n\nVideos\n\n\nComing soon...\n\n\nCode\n\n\nBellow I have provided the source code that I wrote for my Level Editor in Shamballs:\n\n\n#include \"pch.h\"\n#include \"Editor.h\"\n\n#include \"Engine.h\"\n\nEditor::Editor(Level* level)\n{\n    Initialise(level);\n}\n\nEditor::~Editor()\n{\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection;\n    }\n\n    if (m_Level)\n    {\n        delete m_Level;\n        m_Level = 0;\n    }\n}\n\nvoid Editor::Initialise(Level* level)\n{\n    m_Level = level;\n\n    Engine::GetInstance().m_MenuMgr->AddMenu(MenuType::EDITOR);\n\n    Engine::GetInstance().m_Camera->SetCameraMode(CameraMode::FREE);\n\n    CycleEntityType(0);\n}\n\nvoid Editor::Update(float deltaTime)\n{\n    if (!(Engine::GetInstance().m_MenuMgr->m_Open))\n    {\n        Engine::GetInstance().m_InputMgr->ProcessEditorInput(this);\n\n        m_Level->Update(deltaTime);\n        UpdateCurrentSelection(deltaTime);\n    }\n}\n\nvoid Editor::Render()\n{\n    m_Level->Render();\n    if (m_EntitySelection)\n    {\n        m_EntitySelection->Render();\n    }\n    PrintEntitySelection();\n}\n\n// Editor level functions\nbool Editor::ValidateLevel()\n{\n    return false;\n}\n\nbool Editor::SaveLevel()\n{\n    return false;\n}\n\nvoid Editor::UpdateCurrentSelection(float deltaTime)\n{\n    if (m_EntitySelection)\n    {\n        PxTransform transform = (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->getGlobalPose() : m_EntitySelection->GetStaticCollider()->getGlobalPose();\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        float distance = 10.0f;\n\n        transform.p.x = location.x + (distance * cos(camRotation.x) * sin(camRotation.y));\n        transform.p.y = location.y + (distance * sin(camRotation.x));\n        transform.p.z = location.z + (distance * cos(camRotation.x) * cos(camRotation.y));\n\n        Quaternion q = Quaternion::CreateFromYawPitchRoll(m_EntityRotation.y, m_EntityRotation.x, 0.0f);\n        transform.q.w = q.w;\n        transform.q.x = q.x;\n        transform.q.y = q.y;\n        transform.q.z = q.z;\n\n        (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->setGlobalPose(transform) : m_EntitySelection->GetStaticCollider()->setGlobalPose(transform);\n\n        m_EntitySelection->Update(deltaTime);\n    }\n}\n\n// Input handling : Selection\n// Figure out the new entity type to cycle to\nvoid Editor::CycleEntityType(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_EntitySelectionType) + input < 0)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(EntityType::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_EntitySelectionType) + input >= EntityType::COUNT)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(m_EntitySelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleEntitySubType(int input)\n{\n    switch (m_EntitySelectionType)\n    {\n        case EntityType::WORLDBLOCK:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PhysicsSelectionType)+input < 0)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(PhysicsType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PhysicsSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(m_PhysicsSelectionType)+input);\n            }\n            break;\n        case EntityType::PICKUP:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PickupSelectionType)+input < 0)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(PickupType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PickupSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(m_PickupSelectionType)+input);\n            }\n            break;\n    }\n\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleScale(int input)\n{\n    float newValue = static_cast<float>(input) / 2.0f;\n    float newScale = m_EntityScale.x;\n\n    // If the new scale is lower than our min limit, cycle it to the top (max)\n    if (m_EntityScale.x + newValue < m_ScaleMin)\n    {\n        newScale = m_ScaleMax;\n    }\n    // If the new scale is higher than our max limit, cycle it to the bottom (min)\n    else if (m_EntityScale.x + newValue > m_ScaleMax)\n    {\n        newScale = m_ScaleMin;\n    }\n    // We must be still within our scale, so add the new increment (can be negative)\n    else\n    {\n        newScale += newValue;\n    }\n\n    // Set the new scale\n    m_EntityScale.x = newScale;\n    m_EntityScale.y = newScale;\n    m_EntityScale.z = newScale;\n\n    // Update the selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleTexture(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_TextureSelection)+input < 0)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(TextureName::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_TextureSelection)+input >= TextureName::COUNT)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(m_TextureSelection)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleShape(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_ShapeSelectionType)+input < 0)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(EntityShape::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_ShapeSelectionType)+input >= EntityShape::COUNT)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(m_ShapeSelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::SpawnEntitySelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n\n    // Init the new selection entity\n    switch (m_EntitySelectionType)\n    {\n    case EntityType::WORLDBLOCK:\n        m_EntitySelection = new WorldBlock(EntityType::WORLDBLOCK, m_ShapeSelectionType, m_PhysicsSelectionType, m_TextureSelection, PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PLAYERSTART:\n        m_EntitySelection = new PlayerStart(PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    case EntityType::PLAYERFINISH:\n        m_EntitySelection = new PlayerFinish(PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PICKUP:\n        m_EntitySelection = new Pickup(m_PickupSelectionType, PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    }\n\n    // Check if an entity was spawned and disable it's simulation flag\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n        else if (m_EntitySelection->GetPhysicsType() == PhysicsType::STATIC && m_EntitySelection->GetEntityType() != EntityType::PLAYERSTART)\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n\n        UpdateCurrentSelection(0);\n    }\n}\n\nvoid Editor::PlaceSelection()\n{\n    // Add the current selection to the level\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n            m_EntitySelection->GetDynamicCollider()->wakeUp();\n        }\n        else\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n        }\n\n        switch (m_EntitySelectionType)\n        {\n        case EntityType::WORLDBLOCK:\n            m_Level->m_WorldBlocks.push_back(dynamic_cast<WorldBlock*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERSTART:\n            if(m_Level->m_PlayerStart)\n                delete m_Level->m_PlayerStart;\n            m_Level->m_PlayerStart = (dynamic_cast<PlayerStart*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERFINISH:\n            if (m_Level->m_PlayerFinish)\n                delete m_Level->m_PlayerFinish;\n            m_Level->m_PlayerFinish = (dynamic_cast<PlayerFinish*>(m_EntitySelection));\n            break;\n        case EntityType::PICKUP:\n            m_Level->m_Pickups.push_back(dynamic_cast<Pickup*>(m_EntitySelection));\n            break;\n        }\n\n        m_EntitySelection = NULL;\n        SpawnEntitySelection();\n    }\n}\n\nvoid Editor::RemoveSelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n}\n\nvoid Editor::PrintEntitySelection()\n{\n    Engine::GetInstance().m_spriteBatch->Begin();\n\n    Engine::GetInstance().m_font->DrawString(Engine::GetInstance().m_spriteBatch.get(), (m_EntitySelection)? m_EntitySelection->ToString() : L\"None\", Engine::GetInstance().m_fontPos, Colors::OrangeRed, 0.0f,\n        Vector2((Engine::GetInstance().m_outputWidth / -2.0f) + (std::char_traits<wchar_t>::length((m_EntitySelection) ? m_EntitySelection->ToString() : L\"None\")* 26.0f) + 20.0f, (Engine::GetInstance().m_outputHeight / 2.0f)));\n\n    Engine::GetInstance().m_spriteBatch->End();\n}\n\n// Input handling : Directional\nvoid Editor::ApplyCameraForwardInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyForwardInput(input);\n}\n\nvoid Editor::ApplyCameraLeftInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyLeftInput(input);\n}\n\nvoid Editor::ApplyCameraVerticalInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyVerticalInput(input);\n}\n\n// Input handling : Rotational\nvoid Editor::ApplyCameraYawInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyYawInput(input);\n}\n\nvoid Editor::ApplyCameraPitchInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyPitchInput(input);\n}\n\nvoid Editor::ApplySelectionYawInput(float input)\n{\n    m_EntityRotation.y += input;\n}\n\nvoid Editor::ApplySelectionPitchInput(float input)\n{\n    m_EntityRotation.x += input;\n}\n\n\n\n\nDownloads\n\n\nDownload the latest playable alpha build here: \nShamballs - Alpha",
            "title": "Shamballs"
        },
        {
            "location": "/shamballs/#shamballs",
            "text": "Shamballs is 3D competitive singleplayer & multiplayer game where players can race against the clock on custom made levels or battle it our arena style in the multiplayer mode derby!",
            "title": "Shamballs"
        },
        {
            "location": "/shamballs/#background",
            "text": "Shamballs was a three man project created as a group assignment for the Auckland University of Technology. Shamballs was built using the following technologies and languages:     C++    DirectX 11    DirectX Tool Kit    Nvidia PhysX 3.3.3    FMOD     This was my second attempt at a game project since KillShot and my second project with C++ and FMOD. However, working with DirectX, the DirectX Tool Kit and PhysX was a new experience but a rather pleasant one. It provided the strength for Shamballs to standout and become the game we set out to make for this assignment.   \nThere was only a few small features that did not make it into the project before the deadline that were in the origional project pitch and ultimately the whole team was fullfilled with what made it into the final cut.",
            "title": "Background"
        },
        {
            "location": "/shamballs/#project-team-members-contributions",
            "text": "Marc Tucker - marcedforlife@gmail.com  Created most of the base game and architecture  Created the camera system  Created input control methods  Created the level editor  Created the level system  Co-created the menu system  Small extras & bug fixes      Sean Chambers - smchambers95@gmail.com  Implemented sounds  Created game pickups  Created game timers  Small extras      Mathew Bielby - mathewbielby3@gmail.com  Created all the multiplayer components  Assisted with base architecture including menu design  Small extras",
            "title": "Project Team Members &amp; Contributions"
        },
        {
            "location": "/shamballs/#screenshots",
            "text": "In-Game Time Trial:  In-Game Level Editor:",
            "title": "Screenshots"
        },
        {
            "location": "/shamballs/#videos",
            "text": "Coming soon...",
            "title": "Videos"
        },
        {
            "location": "/shamballs/#code",
            "text": "Bellow I have provided the source code that I wrote for my Level Editor in Shamballs:  #include \"pch.h\"\n#include \"Editor.h\"\n\n#include \"Engine.h\"\n\nEditor::Editor(Level* level)\n{\n    Initialise(level);\n}\n\nEditor::~Editor()\n{\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection;\n    }\n\n    if (m_Level)\n    {\n        delete m_Level;\n        m_Level = 0;\n    }\n}\n\nvoid Editor::Initialise(Level* level)\n{\n    m_Level = level;\n\n    Engine::GetInstance().m_MenuMgr->AddMenu(MenuType::EDITOR);\n\n    Engine::GetInstance().m_Camera->SetCameraMode(CameraMode::FREE);\n\n    CycleEntityType(0);\n}\n\nvoid Editor::Update(float deltaTime)\n{\n    if (!(Engine::GetInstance().m_MenuMgr->m_Open))\n    {\n        Engine::GetInstance().m_InputMgr->ProcessEditorInput(this);\n\n        m_Level->Update(deltaTime);\n        UpdateCurrentSelection(deltaTime);\n    }\n}\n\nvoid Editor::Render()\n{\n    m_Level->Render();\n    if (m_EntitySelection)\n    {\n        m_EntitySelection->Render();\n    }\n    PrintEntitySelection();\n}\n\n// Editor level functions\nbool Editor::ValidateLevel()\n{\n    return false;\n}\n\nbool Editor::SaveLevel()\n{\n    return false;\n}\n\nvoid Editor::UpdateCurrentSelection(float deltaTime)\n{\n    if (m_EntitySelection)\n    {\n        PxTransform transform = (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->getGlobalPose() : m_EntitySelection->GetStaticCollider()->getGlobalPose();\n        PxVec3 location = Engine::GetInstance().m_Camera->GetWorldLocation();\n        PxVec3 camRotation = Engine::GetInstance().m_Camera->GetWorldRotation();\n\n        float distance = 10.0f;\n\n        transform.p.x = location.x + (distance * cos(camRotation.x) * sin(camRotation.y));\n        transform.p.y = location.y + (distance * sin(camRotation.x));\n        transform.p.z = location.z + (distance * cos(camRotation.x) * cos(camRotation.y));\n\n        Quaternion q = Quaternion::CreateFromYawPitchRoll(m_EntityRotation.y, m_EntityRotation.x, 0.0f);\n        transform.q.w = q.w;\n        transform.q.x = q.x;\n        transform.q.y = q.y;\n        transform.q.z = q.z;\n\n        (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC) ? m_EntitySelection->GetDynamicCollider()->setGlobalPose(transform) : m_EntitySelection->GetStaticCollider()->setGlobalPose(transform);\n\n        m_EntitySelection->Update(deltaTime);\n    }\n}\n\n// Input handling : Selection\n// Figure out the new entity type to cycle to\nvoid Editor::CycleEntityType(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_EntitySelectionType) + input < 0)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(EntityType::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_EntitySelectionType) + input >= EntityType::COUNT)\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_EntitySelectionType = static_cast<EntityType::EntityType>(static_cast<int>(m_EntitySelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleEntitySubType(int input)\n{\n    switch (m_EntitySelectionType)\n    {\n        case EntityType::WORLDBLOCK:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PhysicsSelectionType)+input < 0)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(PhysicsType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PhysicsSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PhysicsSelectionType = static_cast<PhysicsType::PhysicsType>(static_cast<int>(m_PhysicsSelectionType)+input);\n            }\n            break;\n        case EntityType::PICKUP:\n            // We are bellow our range so cycle to the top\n            if (static_cast<int>(m_PickupSelectionType)+input < 0)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(PickupType::COUNT) - 1);\n            }\n            // We are above our range so cycle to the bottom\n            else if (static_cast<int>(m_PickupSelectionType)+input >= PhysicsType::COUNT)\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(0));\n            }\n            // We are still within range so apply the input\n            else\n            {\n                m_PickupSelectionType = static_cast<PickupType::PickupType>(static_cast<int>(m_PickupSelectionType)+input);\n            }\n            break;\n    }\n\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleScale(int input)\n{\n    float newValue = static_cast<float>(input) / 2.0f;\n    float newScale = m_EntityScale.x;\n\n    // If the new scale is lower than our min limit, cycle it to the top (max)\n    if (m_EntityScale.x + newValue < m_ScaleMin)\n    {\n        newScale = m_ScaleMax;\n    }\n    // If the new scale is higher than our max limit, cycle it to the bottom (min)\n    else if (m_EntityScale.x + newValue > m_ScaleMax)\n    {\n        newScale = m_ScaleMin;\n    }\n    // We must be still within our scale, so add the new increment (can be negative)\n    else\n    {\n        newScale += newValue;\n    }\n\n    // Set the new scale\n    m_EntityScale.x = newScale;\n    m_EntityScale.y = newScale;\n    m_EntityScale.z = newScale;\n\n    // Update the selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleTexture(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_TextureSelection)+input < 0)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(TextureName::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_TextureSelection)+input >= TextureName::COUNT)\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_TextureSelection = static_cast<TextureName::TextureName>(static_cast<int>(m_TextureSelection)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::CycleShape(int input)\n{\n    // We are now below our range so set it to the top\n    if (static_cast<int>(m_ShapeSelectionType)+input < 0)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(EntityShape::COUNT) - 1);\n    }\n    // We are now above our range so it to the bottom\n    else if (static_cast<int>(m_ShapeSelectionType)+input >= EntityShape::COUNT)\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(0);\n    }\n    // We are still within range so apply the direction\n    else\n    {\n        m_ShapeSelectionType = static_cast<EntityShape::EntityShape>(static_cast<int>(m_ShapeSelectionType)+input);\n    }\n\n    // Spawn the updated selection\n    SpawnEntitySelection();\n}\n\nvoid Editor::SpawnEntitySelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n\n    // Init the new selection entity\n    switch (m_EntitySelectionType)\n    {\n    case EntityType::WORLDBLOCK:\n        m_EntitySelection = new WorldBlock(EntityType::WORLDBLOCK, m_ShapeSelectionType, m_PhysicsSelectionType, m_TextureSelection, PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PLAYERSTART:\n        m_EntitySelection = new PlayerStart(PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    case EntityType::PLAYERFINISH:\n        m_EntitySelection = new PlayerFinish(PxVec3(0.0f, 0.0f, 0.0f), Quaternion::Identity, m_EntityScale);\n        break;\n    case EntityType::PICKUP:\n        m_EntitySelection = new Pickup(m_PickupSelectionType, PxVec3(0.0f, 0.0f, 0.0f));\n        break;\n    }\n\n    // Check if an entity was spawned and disable it's simulation flag\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n        else if (m_EntitySelection->GetPhysicsType() == PhysicsType::STATIC && m_EntitySelection->GetEntityType() != EntityType::PLAYERSTART)\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, true);\n        }\n\n        UpdateCurrentSelection(0);\n    }\n}\n\nvoid Editor::PlaceSelection()\n{\n    // Add the current selection to the level\n    if (m_EntitySelection)\n    {\n        if (m_EntitySelection->GetPhysicsType() == PhysicsType::DYNAMIC)\n        {\n            m_EntitySelection->GetDynamicCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n            m_EntitySelection->GetDynamicCollider()->wakeUp();\n        }\n        else\n        {\n            m_EntitySelection->GetStaticCollider()->setActorFlag(PxActorFlag::eDISABLE_SIMULATION, false);\n        }\n\n        switch (m_EntitySelectionType)\n        {\n        case EntityType::WORLDBLOCK:\n            m_Level->m_WorldBlocks.push_back(dynamic_cast<WorldBlock*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERSTART:\n            if(m_Level->m_PlayerStart)\n                delete m_Level->m_PlayerStart;\n            m_Level->m_PlayerStart = (dynamic_cast<PlayerStart*>(m_EntitySelection));\n            break;\n        case EntityType::PLAYERFINISH:\n            if (m_Level->m_PlayerFinish)\n                delete m_Level->m_PlayerFinish;\n            m_Level->m_PlayerFinish = (dynamic_cast<PlayerFinish*>(m_EntitySelection));\n            break;\n        case EntityType::PICKUP:\n            m_Level->m_Pickups.push_back(dynamic_cast<Pickup*>(m_EntitySelection));\n            break;\n        }\n\n        m_EntitySelection = NULL;\n        SpawnEntitySelection();\n    }\n}\n\nvoid Editor::RemoveSelection()\n{\n    // Delete the current (if any) entity selection\n    if (m_EntitySelection)\n    {\n        delete m_EntitySelection;\n        m_EntitySelection = 0;\n    }\n}\n\nvoid Editor::PrintEntitySelection()\n{\n    Engine::GetInstance().m_spriteBatch->Begin();\n\n    Engine::GetInstance().m_font->DrawString(Engine::GetInstance().m_spriteBatch.get(), (m_EntitySelection)? m_EntitySelection->ToString() : L\"None\", Engine::GetInstance().m_fontPos, Colors::OrangeRed, 0.0f,\n        Vector2((Engine::GetInstance().m_outputWidth / -2.0f) + (std::char_traits<wchar_t>::length((m_EntitySelection) ? m_EntitySelection->ToString() : L\"None\")* 26.0f) + 20.0f, (Engine::GetInstance().m_outputHeight / 2.0f)));\n\n    Engine::GetInstance().m_spriteBatch->End();\n}\n\n// Input handling : Directional\nvoid Editor::ApplyCameraForwardInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyForwardInput(input);\n}\n\nvoid Editor::ApplyCameraLeftInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyLeftInput(input);\n}\n\nvoid Editor::ApplyCameraVerticalInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyVerticalInput(input);\n}\n\n// Input handling : Rotational\nvoid Editor::ApplyCameraYawInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyYawInput(input);\n}\n\nvoid Editor::ApplyCameraPitchInput(float input)\n{\n    Engine::GetInstance().m_Camera->ApplyPitchInput(input);\n}\n\nvoid Editor::ApplySelectionYawInput(float input)\n{\n    m_EntityRotation.y += input;\n}\n\nvoid Editor::ApplySelectionPitchInput(float input)\n{\n    m_EntityRotation.x += input;\n}",
            "title": "Code"
        },
        {
            "location": "/shamballs/#downloads",
            "text": "Download the latest playable alpha build here:  Shamballs - Alpha",
            "title": "Downloads"
        },
        {
            "location": "/resume/",
            "text": "Download: \nMarc Tucker - Resume.pdf",
            "title": "Resume"
        },
        {
            "location": "/about/",
            "text": "",
            "title": "About"
        }
    ]
}